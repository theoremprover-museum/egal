(* Title "Preamble Signature for Zermelo's 1908 Proof of the Well-Ordering Theorem" *)
(* Author "Chad E. Brown" *)

(* Unicode False "22A5" *)
Definition False : prop := forall P : prop , P.
Axiom FalseE : forall P : prop , False -> P.
Definition not : prop -> prop := fun A : prop => A -> False.
(* Unicode ~ "00ac" *)
Prefix ~ 700 := not.
Definition and : prop -> prop -> prop := fun A B : prop => forall P : prop , (A -> B -> P) -> P.
(* Unicode /\ "2227" *)
Infix /\ 780 left  := and.
Axiom andI : forall A B : prop , A -> B -> A /\ B.
Axiom andEL : forall A B : prop , A /\ B -> A.
Axiom andER : forall A B : prop , A /\ B -> B.
Definition or : prop -> prop -> prop := fun A B : prop => forall P : prop , (A -> P) -> (B -> P) -> P.
(* Unicode \/ "2228" *)
Infix \/ 785 left  := or.
Axiom orIL : forall A B : prop , A -> A \/ B.
Axiom orIR : forall A B : prop , B -> A \/ B.
Axiom or3I1 : forall P1 P2 P3 : prop, P1 -> P1 \/ P2 \/ P3.
Axiom or3I2 : forall P1 P2 P3 : prop, P2 -> P1 \/ P2 \/ P3.
Axiom or3I3 : forall P1 P2 P3 : prop, P3 -> P1 \/ P2 \/ P3.
Axiom and3I : forall P1 P2 P3 : prop, P1 -> P2 -> P3 -> P1 /\ P2 /\ P3.
Section Poly1_eq.
Variable A : SType.
Definition eq : A -> A -> prop := fun x y => forall Q : A -> prop , Q x -> Q y.
Definition neq : A -> A -> prop := fun x y => ~ eq x y.
End Poly1_eq.
Infix = 502 := eq.
(* Unicode <> "2260" *)
Infix <> 502 := neq.
Section Poly1_eqthms.
Variable A : SType.
Axiom eqI : forall x : A , x = x.
Axiom eq_sym : forall x y : A , x = y -> y = x.
Axiom neq_sym : forall x y : A , x <> y -> y <> x.
End Poly1_eqthms.
Section Poly1_exdef.
Variable A : SType.
Variable Q : A -> prop.
Definition ex : prop := forall P : prop , (forall x : A , Q x -> P) -> P.
End Poly1_exdef.
(* Unicode exists "2203" *)
Binder+ exists , := ex.
Section Poly1_exthms.
Variable A : SType.
Axiom exI : forall P : A -> prop , forall x : A , P x -> exists x : A , P x.
End Poly1_exthms.
Section PredPoly1.
Variable A : SType.
Definition bigintersect := fun (D : (A -> prop) -> prop) (x : A) => forall P : A -> prop , D P -> P x.
End PredPoly1.
Section PE.
Variable A : SType.
Axiom pred_ext : forall P Q : A -> prop , P c= Q -> Q c= P -> P = Q.
End PE.
Section RelnPoly1.
Variable A : SType.
Definition reflexive : (A -> A -> prop) -> prop := fun R => forall x : A , R x x.
Definition irreflexive : (A -> A -> prop) -> prop := fun R => forall x : A , ~ R x x.
Definition symmetric : (A -> A -> prop) -> prop := fun R => forall x y : A , R x y -> R y x.
Definition antisymmetric : (A -> A -> prop) -> prop := fun R => forall x y : A , R x y -> R y x -> x = y.
Definition transitive : (A -> A -> prop) -> prop := fun R => forall x y z : A , R x y -> R y z -> R x z.
Definition linear : (A -> A -> prop) -> prop := fun R => forall x y : A , R x y \/ R y x.
Definition trichotomous_or : (A -> A -> prop) -> prop := fun R => forall x y : A , R x y \/ x = y \/ R y x.
Definition partialorder : (A -> A -> prop) -> prop := fun R => reflexive R /\ antisymmetric R /\ transitive R.
Definition totalorder : (A -> A -> prop) -> prop := fun R => partialorder R /\ linear R.
Definition strictpartialorder : (A -> A -> prop) -> prop := fun R => irreflexive R /\ transitive R.
Definition stricttotalorder : (A -> A -> prop) -> prop := fun R => strictpartialorder R /\ trichotomous_or R.
Axiom partialorder_strictpartialorder : forall R : A -> A -> prop , partialorder R -> strictpartialorder (fun x y => R x y /\ x <> y).
End RelnPoly1.
Section Choice.
Variable A : SType.
Parameter Eps : (A -> prop) -> A.
Axiom EpsR : forall P : A -> prop , forall x : A , P x -> P (Eps P).
End Choice.
Binder some , := Eps.
Section ChoiceThms.
Variable A : SType.
Axiom EpsR2 : forall P : A -> prop , (exists x : A , P x) -> P (some x : A , P x).
End ChoiceThms.
Axiom classic : forall P : prop , P \/ ~ P.
Axiom NNPP : forall p : prop , ~ ~ p -> p.
